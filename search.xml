<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title><![CDATA[ElasticSearch + Redis的一个应用实例]]></title>
    <url>%2F2017%2F07%2F10%2FElasticSearch-Redis%2F</url>
    <content type="text"><![CDATA[应用实例 使用场景在ElasticSearch中的device索引里共有9688085条记录，每条记录包含了一些信息，如用户id，设备guid，设备型号以及用户经纬度。现在希望根据这些数据当中的经纬度值，计算出用户分布的统计结果。当然在对这些数据进行处理之前，肯定是要进行筛选的，比如去除一些没有获取到经纬度的记录等，最后剩余大约700W+的数据。数据筛选的部分暂且略过。 存在问题 700W+的数据存储在ES当中，如何遍历这些数据？ 对于每一条记录当中的经纬度值，需要调用地理位置信息接口获取该经纬度对应的地址，并按照省市划分，如何在数据量不断增大的同时，能够保证这样的数据结构，并实现快速的存、取？ 最终形成的统计结果，怎样实现可视化？ 解决方案 Q1：采用ES的scroll翻页查询。ES支持两种翻页方式：（1）第一种是类似于sql中limit，在ES中是from/size。这种方式在数据量不大的情况下是可以使用的，但是在深度分页的情况下效率极低。它的原理是返回size条数据，然后从from处截断。所以当我要查询from=10000，size=10010的数据时，会查询前10010条数据，但是只截取10000-10010条数据返回。这就造成了极大的浪费。（2）第二种是类似于sql中的cursor，在ES中是scroll查询。scroll查询会在前一次的查询的基础上继续查询。在查询时添加一个scroll参数，用来指定游标查询的过期时间。这个时间会在每次查询时刷新，所以这个时间只需要足够处理当前批次的结果就可以了，而不是处理查询结果的所有文档的时间。对于大批量的数据，需要用scroll查询来获取数据。 Q2：使用Redis做存储和查询。Redis作为一个内存中的数据结构存储系统，可以被用作数据库、缓存和消息中间件。丰富的数据结构类型（如 字符串（strings）， 散列（hashes）， 列表（lists）， 集合（sets）， 有序集合（sorted sets）），对这些类型的原子操作，持久化以及主从复制等功能Redis都能够提供。由于数据量会迅速增大，高效率的查询和更新是必须满足的，redis作为内存型的数据库就是以速度著称。另外省：市：数量 这样的数据结构，可以使用redis中的哈希键（key-field-value）来实现。 Q3：统计结果写入日志文件。对于最后的统计结果，可以通过遍历redis中的哈希键来获取field和value，将结果记录到日志文件中。 代码实现 1 - ES和Redis配置 Redis配置主要是host，port和pwd。ES配置中要说明的是type_name，由于在对应的index下有多个type，所以我在这里指定了我要查询的type。 2 - 构造方法初始化redis 3 - 初始化查询，获取scroll_id [★] 在ES中使用游标查询，需要在普通的查询基础上，添加scroll参数，值代表游标过期时间，如（scroll=1m）。在查询返回的结果中，得到名为’_scroll_id’的值，作为下一次查询的游标id。 4 - 初始化查询后，使用scroll_id继续查询[★] 在得到游标id以后，就不需要继续指明查询条件了。 5 - 使用curl发送请求到es 这里的就是一个常规的curl请求方式。需要注意的是对于传入的data参数的分解，这样处理之后可以支持批量查询，分解的原因参考ES的批量查询。 6 - 计算统计分布[★] 计算分布时调用了根据GPS信息获取地理位置信息的接口，返回结果里会包含详细的省市县以及街道等信息。 7 - 结果写入日志文件 8 - 释放redis中的数据 由于在往Redis中存储时使用了哈希键，而键使用了省级名称，所以可以按照省级名称为key的方式，释放Redis当中的数据。 9 - 最终的run方法 综合上边的一系列方法后得到的run方法。 注：在使用redis的hGetAll方法时，遇到了段错误（segmentation fault）。当时php版本是7.0.9，在使用php 7.0.16运行脚本后解决。]]></content>
      <categories>
        <category>es</category>
      </categories>
      <tags>
        <tag>es</tag>
        <tag>redis</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[regular expression]]></title>
    <url>%2F2017%2F06%2F12%2Fregular-expression%2F</url>
    <content type="text"><![CDATA[平时会经常使用正则表达式来对字符串进行一些抽取和分析，这里对正则表达式的基本语法进行梳理，并结合我实际过程中的使用加以解释。正则表达式(regular expression)描述了一种字符串匹配的模式（pattern），它作为一个模板，将某个字符模式与所搜索的字符串进行匹配。可以用来检查一个串是否含有某种子串、将匹配的子串替换或者从某个串中取出符合某个条件的子串等。 正则中的字符非打印字符常见非打印字符的转义序列： 字符 描述 \n 匹配一个换行符 \r 匹配一个回车（回到首行）符 \s 匹配任何空白字，包括空格，制表符，换页符等 \S 匹配任何非空白字符 \t 匹配一个制表符 特殊字符特殊字符就是一些有特殊含义的字符。许多元字符要求在试图匹配它们时特别对待。若要匹配这些字符，必须先对这些字符进行转义，即，将反斜杠字符 ‘\’ 放在它们前面。正则表达式中的特殊字符： 字符 描述 ^ 匹配输入字符串的开始位置，除非在方括号表达式中使用，此时它表示不接受该字符集合。要匹配 ^ 字符本身，请使用 \^。 $ 匹配输入字符串的结尾位置。要匹配 $ 字符本身，请使用 \$。 () 标记一个子表达式的开始和结束位置。子表达式可以获取供以后使用。要匹配这些字符，请使用 ( 和 )。 * 匹配前面的子表达式零次或多次，等价于{0,}。要匹配 字符，请使用 \。 + 匹配前面的子表达式一次或多次，等价于{1,}。要匹配 + 字符，请使用 +。 . 匹配除换行符 \n 之外的任何单字符。要匹配 . ，请使用 \ . 。 ? 匹配前面的子表达式零次或一次，或指明一个非贪婪限定符。要匹配 ? 字符，请使用 \?。 \ 指明两项之间的一个选择。要匹配该字符，请使用转义 限定符限定符用来指定正则表达式的一个给定组件必须要出现多少次才能满足匹配。有 * 或 + 或 ? 或 {n} 或 {n,} 或 {n,m} 共6种。 正则表达式的限定符有： 字符 描述 {n} n 是一个非负整数。匹配确定的 n 次。 {n,} n 是一个非负整数。至少匹配n 次。 {n,m} m 和 n 均为非负整数，其中n &lt;= m。最少匹配 n 次且最多匹配 m 次。 *、+和?限定符都是贪婪的，因为它们会尽可能多的匹配文字，只有在它们的后面加上一个?就可以实现非贪婪或最小匹配。 定位符定位符能够将正则表达式固定到行首或行尾。 正则表达式的定位符有： 字符 描述 ^ 匹配输入字符串开始的位置。在[ ]中使用，代表非或排除的含义 $ 匹配输入字符串结尾的位置。 \b 匹配一个字边界，即字与空格间的位置。 \B 非字边界匹配 关于\b和\B的例子： /\bCha/ : 匹配单词 Chapter 的开头三个字符; /ter\b/ : 单词 Chapter 中的字符串 ter，因为它出现在字边界的前面; /\Bapt/ : 匹配 Chapter 中的字符串 apt，但不匹配 aptitude 中的字符串 apt。 因为字符串 apt 出现在单词 Chapter 中的非字边界处，但出现在单词 aptitude 中的字边界处。 项目中的实例（1）有这样一个字符串：’op_content-&gt;”$.roomid”‘ 或 ‘op_content-&gt;”$.rid”‘。现在需要将roomid或者rid抽取出来。 在php中的实现： 1&apos;/^(op_content-&gt;\&quot;\$\.)+(\w+)/&apos; （2）对于字符串： ① ‘/panda/fa6d953b44b505dee6522d2be6e29b66.flv?domain=flv-live-qn.panda.tv’ ② ‘/panda/fa6d953b44b505dee6522d2be6e29b66.flv’。 需要从中抽取出：① panda；② fa6d953b44b505dee6522d2be6e29b66； ③ flv 在php中的实现： 1&apos;#/(.+)/(\w+)\.(\w+)#&apos; 在php中的正则，匹配模式的开头与结尾需要成对，即上边所看到的#。由于需要匹配字符串中的/，所以不能再以/开头和结尾。同样的，如果需要匹配字符串中的特殊符号，该特殊符号也不可以作为开头和结尾的标识。]]></content>
      <categories>
        <category>regular</category>
      </categories>
      <tags>
        <tag>regular</tag>
        <tag>expression</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Time Zone]]></title>
    <url>%2F2017%2F06%2F08%2Ftimezone%2F</url>
    <content type="text"><![CDATA[最近在分析CDN拉流日志的时候，看到了这样的时间格式：2017-06-06T00:58:13+08:00一直对于各种时间缩写不太清楚，于是整理一篇关于这方面的内容。 上边的日期格式什么含义？先说结论：2017-06-06T00:58:13+08:00，它代表东八区2017年6月6日00点58分13秒。为什么日期格式中间还有一个T呢？这是国际标准化组织的日期和时间表示方法规定的。 wikipedia链接：国际标准ISO 8601 在ISO 8601中规定，在合并表示日期和时间的时候，要在时间前边加大写字母T +08:00代表，该时间所属的时区是东八区 各种时间概念UTC整个地球被分为24个时区，每个时区都有自己的本地时间，正如上边的北京时间一样。为了统一起见，出现了协调世界时，又称世界标准时间或世界协调时间，简称UTC(Universal Time Coordinated)，是最主要的世界时间标准，其以原子时秒长为基础，在时刻上接近于格林尼治标准时间。 本地时间与UTC转换：UTC + 时区 = 本地时间。时区东为正，西为负。如东八区表示为+08:00。 GMTGMT(Greenwich Mean Time)格林尼治标准时间（有些翻译为格林尼治平均时间）。但是由于地球在它的椭圆轨道里运行速度不均匀，这个时刻可能与实际的太阳时有误差。格林尼治时间基于天文观测本身的缺陷，已经不再被作为标准时间使用。现在的标准时间，是由原子钟报时的协调世界时（UTC）来决定的。 DST夏日节约时间，简称DST(Daylight Saving Time)。夏季太阳升起较早，人为地将时间提前一小时，以充分利用光照资源，节约照明用电。这个构想于1784年由美国班杰明•富兰克林提出来，1915年德国成为第一个正式实施夏令日光节约时间的国家，以削减灯光照明和耗电开支。 自此以后，全球以欧洲和北美为主的约70个国家都引用这个做法。它与UTC和GMT完全没有关系，完全是人为行为。 CSTCST可以指下列的时区： 大中华地区时区：China Standard Time 澳洲中部时间：Central Standard Time (Australia) 中部标准时区（北美洲），Central Standard Time (North America) 古巴标准时间，Cuba Standard Time 因此，CST是转换后的本地时间。如果忽略UTC和GMT的差异，可以认为中国北京的标准时间为： GMT + 8 = UTC + 8 = CST EST/PST等美国横跨西五区至西十区，共六个时区。每个时区对应一个标准时间，从东向西分别为： 东部时间(EST)(西五区时间) 中部时间(CST)(西六区时间) 山地时间(MST)(西七区时间) 太平洋时间(西部时间)(PST)(西八区时间) 阿拉斯加时间(AKST)(西九区时间) 夏威夷时间(HST) (西十区时间)按照“东早西晚”的规律，各递减一小时。 以上所提到的各种时间里，UTC和GMT是和时区无关的，而CST/DST等是与时区紧密相关的。 计算机时间计算机保存的时间是自UTC时间1970年1月1日00:00:00经过的秒数。最早出现的UNIX操作系统考虑到计算机产生的年代和应用的时限综合取了1970年1月1日作为UNIX TIME的纪元时间(开始时间)。时间戳是指格林威治时间1970年01月01日00时00分00秒(北京时间1970年01月01日08时00分00秒)起至现在的总秒数。]]></content>
      <categories>
        <category>timezone</category>
      </categories>
      <tags>
        <tag>timezone</tag>
        <tag>UTC</tag>
        <tag>GMT</tag>
        <tag>DST</tag>
        <tag>CST</tag>
        <tag>EST</tag>
        <tag>PST</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[xdebug -- debug tool for php]]></title>
    <url>%2F2017%2F06%2F01%2Fxdebug%2F</url>
    <content type="text"><![CDATA[如果你现在的调试还是在使用var_dump()或者print_r()，那么xdebug可能会让你的调试更加得心应手，就像平常断点单步调试一样，你可以直观的看见所有的过程与值。与任何东西的学习方式一样，官方文档 永远是最好的老师： xdebug官方文档 :) 什么？你不想看英文文档？ 还好你找到了这里~下边是linux下xdebug的安装及配置方法： Step 1 下载并解压xdebug扩展包12wget https://xdebug.org/files/xdebug-2.5.4.tgztar -zxvf xdebug-2.5.4.tgz Tips： 具体下载哪个版本的包，可以到xdebug的download页面查找：download windows用户下载.dll后缀的文件，linux用户下载source包 Step 2 编译xdebug12345cd debug-2.5.4phpize（编译你要添加的扩展模块的命令）./configuremakecp modules/xdebug.so /usr/local/php-7.0.9/lib/php/extensions/no-debug-non-zts-20151012 Step 3 配置php.ini对于PHP5.3之前的版本： add: zend_extension_ts=”/wherever/you/put/it/xdebug.so” 对于PHP5.3之后的版本（我的php版本是7.0.9）： From PHP 5.3 onwards, you always need to use the zend_extension PHP.ini setting name, and not zend_extension_ts, nor zend_extension_debug. 在我的php.ini中，关于xdebug的配置如下： 其中remote_host与remote_port按照自己的需求指定。保存php.ini后重启apache或nginx。 Step 4 配置phpstorm的xdebug1. 指定xdebug port这里的port需要与php.ini配置的remote_port一致。 2. 配置DBGp ProxyIDE Key：与php.ini中xdebug.idekey相同Host：项目所在位置Port：项目监听端口 Step 5 安装chrome扩展 Xdebug helper在IDE Key中选择PhpStorm，并设置Key为PHPSTORM（与之前的xdebug.idekey相同即可） 到此为止，所有的准备工作就已经完成了，下面来测试一下~！ Step 6 测试 在phpstorm中设置代码断点，然后开启debug监听 打开浏览器中Xdebug helper的debug模式 访问存在断点的代码位置如果没问题的话，在phpstorm中应该可以看到： 进入debug控制台点击accept就可以看到debug控制台了 that’s done~!]]></content>
      <categories>
        <category>php</category>
      </categories>
      <tags>
        <tag>xdebug</tag>
        <tag>php</tag>
        <tag>phpstorm</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[First Step]]></title>
    <url>%2F2017%2F05%2F31%2Ffirst-blog%2F</url>
    <content type="text"><![CDATA[这是我的第一篇博文，采用了hexo + Github Pages构建博客网站，其中还用到了node.js和 git。 构建博客网站的工作并不复杂，过程就不再赘述了，给出一些建站的参考网站： Reference URL： GitPages + Hexo从0到1搭建个人博客 Hexo在github上构建免费的Web应用 NexT主题 从这篇文章开始，来看看会发生什么。]]></content>
      <tags>
        <tag>first</tag>
        <tag>hexo</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Hello World]]></title>
    <url>%2F2017%2F05%2F31%2Fhello-world%2F</url>
    <content type="text"><![CDATA[Welcome to Hexo! This is your very first post. Check documentation for more info. If you get any problems when using Hexo, you can find the answer in troubleshooting or you can ask me on GitHub. Quick StartCreate a new post1$ hexo new "My New Post" More info: Writing Run server1$ hexo server More info: Server Generate static files1$ hexo generate More info: Generating Deploy to remote sites1$ hexo deploy More info: Deployment]]></content>
  </entry>
</search>
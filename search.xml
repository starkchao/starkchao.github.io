<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title><![CDATA[《Redis设计与实现》笔记：数据结构与对象 - 简单动态字符串]]></title>
    <url>%2F2017%2F11%2F15%2FRedis-design-SDS%2F</url>
    <content type="text"><![CDATA[Redis没有直接使用C语言传统的字符串表示（以空字符（’\0’）结尾的字符数组），而是自己构建了一种名为简单动态字符串（simply dynamic string，SDS）的抽象类型，并将SDS用作Redis的默认字符串表示。 简介在Redis里，C字符串只会作为字符串字面量，用在一些无需对字符串值进行修改的地方，比如打印日志： redisLog(REDIS_WARNING,”Redis is now ready to exit, bye bye…”); 当Redis需要一个可以被修改的字符串值时，Redis就会使用SDS来表示字符串值，比如包含字符串值的键值对在底层就是由SDS实现的。 例如客户端执行命令： redis&gt; SET msg “hello world”OK 那么Redis将在数据库中创建了一个新的键值对，其中： 键值对的键是一个字符串对象，对象的底层实现是一个保存着字符串“msg”的SDS 键值对的值也是一个字符串对象，对象的底层实现是一个保存着字符串“hello world”的SDS SDS的定义SDS图示例：图1 free属性值为0，代表SDS没有未使用空间 len属性值为5，代表SDS保存了5字节长的字符串 buf属性是一个char类型的数组，数组前五个字节分别保存了’R’,’e’,’d’,’i’,’s’，最后一个字节保存了空字符’\0’可以看到，SDS遵循了C字符串以空字符结尾的惯例，这样做的好处是SDS可以直接重用C字符串里的一些函数。此外，保存空字符的1字节空间不计算在SDS的len属性里面。为空字符分配1字节空间以及添加空字符到字符串末尾等操作都是由SDS函数自动完成。 SDS与C字符串的区别SDS比传统的C字符串更能满足Redis对字符串在安全性、效率、已经功能方面的要求。 1.常数复杂度获取字符串长度由于C字符串并不记录自身的长度信息，所以为了获取一个字符串的长度，必须遍历整个字符串，对遇到的每个字符进行计数，直到遇到代表字符串结尾的空字符为止，这个操作的复杂度为O(N)。而SDS在len属性中记录了SDS本身的长度，所以获取一个SDS长度的复杂度为O(1)，并且设置和更新SDS长度的工作是由SDS的API在执行时自动完成的。通过使用SDS，Redis将获取字符串长度所需的复杂度从O(N)降低到了O(1)，这确保了获取字符串长度的工作不会成为Redis的性能瓶颈。 2.杜绝缓冲区溢出C字符串不记录自身长度带来的另外一个问题就是容易造成缓冲区溢出（buffer overflow）举个例子，strcat函数将src字符串中的内容拼接到dest字符串的末尾： char strcat(char dest, const char *src); 由于C字符串不记录自身的长度，所以strcat假定用户在执行这个函数时，已经为dest分配了足够多的内存，可以容纳src字符串中的所有内容，而一旦这个假设不成立时，就会产生缓冲区溢出。 举个例子，假如程序里有两个在内存中紧邻着的C字符串s1和s2，其中s1保存了字符串“Redis”，s2保存了字符串“MongoDB”，如下图：图2如果执行： strcat(s1, “ Cluster”); 目的是将s1的内容修改为“Redis Cluster”，但在执行之前却没有为s1分配足够的空间，那么在strcat函数执行之后，s1的数据将溢出到s2所在的空间中，导致s2保存的内容被意外地修改，图3 与C字符串不同，SDS的空间分配策略完全杜绝了发生缓冲区溢出的可能性。举个例子：SDS的API里面也有一个执行拼接操作的sdscat函数，它可以将一个C字符串拼接到给定SDS所保存的字符串的后面，但是在执行拼接操作之前，sdscat会先检查给定SDS的空间是否足够（利用free属性），如果不够的话，sdscat就会先扩展SDS的空间，然后才执行拼接操作。下边的小节对SDS的空间分配策略进行说明。 3.减少修改字符串时带来的内存重分配次数由于C字符串并不记录自身长度，所以每次增长或缩短一个C字符串，程序都要对保存这个C字符串的数组进行一次内存重分配操作，包括扩展底层数组的空间大小或释放不再使用的那部分空间。在一般的程序中，如果修改字符串的情况不太常出现，那么每次修改都执行一次内存重分配是可以接受的。但Redis被应用于数据被频繁修改的场合，显然每次都执行内存重分配是无法接受的。 敲黑板画重点了:为了避免C字符串的这种缺陷，在SDS中使用free属性来标识未使用空间，通过未使用空间，SDS实现了空间预分配和惰性空间释放两种优化策略。- 空间预分配 空间预分配用于优化SDS的字符串增长操作：当SDS的API对一个SDS进行修改，并且需要对SDS进行空间扩展的时候，程序不仅会为SDS分配修改所必须要的空间，还会为SDS分配额外的未使用空间。其中，额外分配的未使用空间数量由以下公式决定： 如果对SDS进行修改之后，SDS的长度（即len属性值）小于1MB，那么程序分配和len属性同样大小的未使用空间，这时SDS len属性的值将和free属性的值相同。 如果对SDS进行修改之后，SDS的长度大于等于1MB，那么程序会分配1MB的未使用空间。 举个例子,对于图1所示的SDS值，如果我们执行 sdscat(s, “ Cluster”); 那么sdscat将执行一次内存重分配操作，将SDS的长度（len属性）修改为13字节，并将SDS的未使用空间（free属性）同样修改为13字节，如下图：图4如果这时，我们再次执行: sdscat(s, “ Tutorial”); 那么这次sdscat将不需要执行内存重分配：因为未使用空间里面的13字节足以保存9字节的”Tutorial”，执行之后如下图：图5通过这种预分配策略，SDS将连续增长N次字符串所需的内存重分配次数，从必定的N次降低为最多N次。 惰性空间释放 惰性空间释放用于优化SDS的字符串缩短操作：当SDS的API需要缩短SDS保存的字符串时，程序并不立即使用内存重分配来回收缩短后多出来的字节，而是使用free属性将这些字节的数量记录，并等待将来使用。 举个例子，sdstrim函数接受一个SDS和一个C字符串作为参数，从SDS左右两端分别移除所有在C字符串中出现过的字符，比如执行：sdstrim(s, “XY”); // 移除 SDS 字符串中的所有 ‘X’ 和 ‘Y’ 会将SDS修改为如下图的样子：图6注意执行sdstrim之后的SDS并没有释放多出来的8字节空间，而是将这8字节空间作为未使用空间保留在了SDS里面，如果将来要对SDS进行增长操作的话，这些未使用空间就可能派上用场了。 举个例子，如果现在执行：sdscat(s, “ Redis”); 那么完成这次sdscat操作将不需要执行内存重分配：因为SDS里面预留的8字节空间已经足以拼接6字节长的”Redis”。 重点来了：通过惰性空间释放策略，SDS避免了缩短字符串时所需的内存重分配操作，并为将来可能有的增长操作提供了优化。与此同时，SDS也提供了相应的API，在有需要时，真正地释放SDS里面的未使用空间，因而不必担心惰性空间释放策略会造成内存浪费。 4.二进制安全C字符串除了字符串的末尾之外，字符串里面不能包含空字符，否则最先被程序读入的空字符将被误认为是字符串结尾——这些限制使得C字符串只能保存文本数据，而不能保存像图片、音频、视频这样的二进制数据。而SDS的API都是二进制安全的：所有SDS API都会以处理二进制的方式来处理SDS存放在buf数组的数据。通过使用二进制安全的SDS，使得Redis不仅可以保存文本数据，还可以保存任意格式的二进制数据。 5.兼容部分C字符串函数虽然SDS的API都是二进制安全的，但它们一样遵循C字符串以空字符结尾的惯例，因此SDS可以在有需要时重用函数库，从而避免了不必要的代码重复。 总结一下 最后的重点:C字符串和SDS之间的区别：]]></content>
      <categories>
        <category>redis</category>
      </categories>
      <tags>
        <tag>redis</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[ElasticSearch中嵌套聚合的使用]]></title>
    <url>%2F2017%2F09%2F12%2FElasticSearch-Aggs%2F</url>
    <content type="text"><![CDATA[在ElasticSearch中，通过聚合我们可以向数据提出一些更为复杂和精细的问题，这样的问题是对数据的分析和总结，而不再是寻找单个文档。下边首先介绍在ES中关于聚合的一些概念，随后会给出几个嵌套聚合的使用实例。 基本概念 桶桶简单来说就是满足特定条件的文档的集合，桶也可以进行嵌套，提供更为复杂和精细的划分方案。此外，ElasticSearch提供多种类型的桶，能让你通过多种方式来划分文档。 指标通过桶，我们将文档划分到了有意义的集合中，但这还不够。我们需要对桶内的文档按照某些指标进行计算。大多数指标是简单的数学运算（例如最大/最小值，平均值）。 将桶和指标结合起来，就可以开始使用聚合了。 应用实例 1 - 计算弹幕量 计算要求：现在需要按照房间计算每五分钟里的弹幕量，给出结果里的前一百名。根据要求，可以看出两个聚合条件：首先，以房间为维度进行聚合，之后嵌套聚合里按照时间进行划分，时间跨度为5分钟。 ES查询语句： 查询语句解析： ① size设置为0，因为我们并不关心搜索结果的具体内容，我们关心的是聚合以后的结果。 ② query里指定搜索的条件，这里用到了正则表达式来对弹幕内容进行过滤。 ③ aggs（与完整形式aggregations等价）就是聚合操作，它被置于顶层参数之下。 聚合名称：xid。桶的类型：terms桶。terms桶会为每个碰到的唯一词项创建新的桶。在这里我们指定了room字段，即为每个房间创建一个桶。结果数量：size指定为100，返回前100条。 ④ 接下来是一个嵌套桶。 聚合名称：times。桶的类型：date_histogram桶。 时间间隔：interval字段代表时间间隔，这里指定为5分钟。时区：将es中记录的标准时间转换为东八区时间。文档数量：限制文档数量最小值，来减少返回结果的大小。排序规则：按照文档数量，降序排序。 2 - 计算消费总价 计算要求：与前一个实例要求类似，区别在于计算消费总价相当于又多了一层聚合的嵌套。 ES查询语句： 查询语句解析： ① query里指定搜索的条件，这里用到了前缀匹配来对字段进行过滤。 ② 第三层聚合利用里sum度量指标，来计算每个房间以五分钟为时间间隔的消费总价。]]></content>
      <categories>
        <category>es</category>
      </categories>
      <tags>
        <tag>es</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[ElasticSearch + Redis的一个应用实例]]></title>
    <url>%2F2017%2F07%2F10%2FElasticSearch-Redis%2F</url>
    <content type="text"><![CDATA[应用实例 使用场景在ElasticSearch中的device索引里共有9688085条记录，每条记录包含了一些信息，如用户id，设备guid，设备型号以及用户经纬度。现在希望根据这些数据当中的经纬度值，计算出用户分布的统计结果。当然在对这些数据进行处理之前，肯定是要进行筛选的，比如去除一些没有获取到经纬度的记录等，最后剩余大约700W+的数据。数据筛选的部分暂且略过。 存在问题 700W+的数据存储在ES当中，如何遍历这些数据？ 对于每一条记录当中的经纬度值，需要调用地理位置信息接口获取该经纬度对应的地址，并按照省市划分，如何在数据量不断增大的同时，能够保证这样的数据结构，并实现快速的存、取？ 最终形成的统计结果，怎样实现可视化？ 解决方案 Q1：采用ES的scroll翻页查询。ES支持两种翻页方式：（1）第一种是类似于sql中limit，在ES中是from/size。这种方式在数据量不大的情况下是可以使用的，但是在深度分页的情况下效率极低。它的原理是返回size条数据，然后从from处截断。所以当我要查询from=10000，size=10010的数据时，会查询前10010条数据，但是只截取10000-10010条数据返回。这就造成了极大的浪费。（2）第二种是类似于sql中的cursor，在ES中是scroll查询。scroll查询会在前一次的查询的基础上继续查询。在查询时添加一个scroll参数，用来指定游标查询的过期时间。这个时间会在每次查询时刷新，所以这个时间只需要足够处理当前批次的结果就可以了，而不是处理查询结果的所有文档的时间。对于大批量的数据，需要用scroll查询来获取数据。 Q2：使用Redis做存储和查询。Redis作为一个内存中的数据结构存储系统，可以被用作数据库、缓存和消息中间件。丰富的数据结构类型（如 字符串（strings）， 散列（hashes）， 列表（lists）， 集合（sets）， 有序集合（sorted sets）），对这些类型的原子操作，持久化以及主从复制等功能Redis都能够提供。由于数据量会迅速增大，高效率的查询和更新是必须满足的，redis作为内存型的数据库就是以速度著称。另外省：市：数量 这样的数据结构，可以使用redis中的哈希键（key-field-value）来实现。 Q3：统计结果写入日志文件。对于最后的统计结果，可以通过遍历redis中的哈希键来获取field和value，将结果记录到日志文件中。 代码实现 1 - ES和Redis配置 Redis配置主要是host，port和pwd。ES配置中要说明的是type_name，由于在对应的index下有多个type，所以我在这里指定了我要查询的type。 2 - 构造方法初始化redis 3 - 初始化查询，获取scroll_id [★] 在ES中使用游标查询，需要在普通的查询基础上，添加scroll参数，值代表游标过期时间，如（scroll=1m）。在查询返回的结果中，得到名为’_scroll_id’的值，作为下一次查询的游标id。 4 - 初始化查询后，使用scroll_id继续查询[★] 在得到游标id以后，就不需要继续指明查询条件了。 5 - 使用curl发送请求到es 这里的就是一个常规的curl请求方式。需要注意的是对于传入的data参数的分解，这样处理之后可以支持批量查询，分解的原因参考ES的批量查询。 6 - 计算统计分布[★] 计算分布时调用了根据GPS信息获取地理位置信息的接口，返回结果里会包含详细的省市县以及街道等信息。 7 - 结果写入日志文件 8 - 释放redis中的数据 由于在往Redis中存储时使用了哈希键，而键使用了省级名称，所以可以按照省级名称为key的方式，释放Redis当中的数据。 9 - 最终的run方法 综合上边的一系列方法后得到的run方法。 注：在使用redis的hGetAll方法时，遇到了段错误（segmentation fault）。当时php版本是7.0.9，在使用php 7.0.16运行脚本后解决。]]></content>
      <categories>
        <category>es</category>
      </categories>
      <tags>
        <tag>es</tag>
        <tag>ElasticSearch</tag>
        <tag>redis</tag>
        <tag>scroll</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[regular expression]]></title>
    <url>%2F2017%2F06%2F12%2Fregular-expression%2F</url>
    <content type="text"><![CDATA[平时会经常使用正则表达式来对字符串进行一些抽取和分析，这里对正则表达式的基本语法进行梳理，并结合我实际过程中的使用加以解释。正则表达式(regular expression)描述了一种字符串匹配的模式（pattern），它作为一个模板，将某个字符模式与所搜索的字符串进行匹配。可以用来检查一个串是否含有某种子串、将匹配的子串替换或者从某个串中取出符合某个条件的子串等。 正则中的字符非打印字符常见非打印字符的转义序列： 字符 描述 \n 匹配一个换行符 \r 匹配一个回车（回到首行）符 \s 匹配任何空白字，包括空格，制表符，换页符等 \S 匹配任何非空白字符 \t 匹配一个制表符 特殊字符特殊字符就是一些有特殊含义的字符。许多元字符要求在试图匹配它们时特别对待。若要匹配这些字符，必须先对这些字符进行转义，即，将反斜杠字符 ‘\’ 放在它们前面。正则表达式中的特殊字符： 字符 描述 ^ 匹配输入字符串的开始位置，除非在方括号表达式中使用，此时它表示不接受该字符集合。要匹配 ^ 字符本身，请使用 \^。 $ 匹配输入字符串的结尾位置。要匹配 $ 字符本身，请使用 \$。 () 标记一个子表达式的开始和结束位置。子表达式可以获取供以后使用。要匹配这些字符，请使用 ( 和 )。 * 匹配前面的子表达式零次或多次，等价于{0,}。要匹配 字符，请使用 \。 + 匹配前面的子表达式一次或多次，等价于{1,}。要匹配 + 字符，请使用 +。 . 匹配除换行符 \n 之外的任何单字符。要匹配 . ，请使用 \ . 。 ? 匹配前面的子表达式零次或一次，或指明一个非贪婪限定符。要匹配 ? 字符，请使用 \?。 \ 指明两项之间的一个选择。要匹配该字符，请使用转义 限定符限定符用来指定正则表达式的一个给定组件必须要出现多少次才能满足匹配。有 * 或 + 或 ? 或 {n} 或 {n,} 或 {n,m} 共6种。 正则表达式的限定符有： 字符 描述 {n} n 是一个非负整数。匹配确定的 n 次。 {n,} n 是一个非负整数。至少匹配n 次。 {n,m} m 和 n 均为非负整数，其中n &lt;= m。最少匹配 n 次且最多匹配 m 次。 *、+和?限定符都是贪婪的，因为它们会尽可能多的匹配文字，只有在它们的后面加上一个?就可以实现非贪婪或最小匹配。 定位符定位符能够将正则表达式固定到行首或行尾。 正则表达式的定位符有： 字符 描述 ^ 匹配输入字符串开始的位置。在[ ]中使用，代表非或排除的含义 $ 匹配输入字符串结尾的位置。 \b 匹配一个字边界，即字与空格间的位置。 \B 非字边界匹配 关于\b和\B的例子： /\bCha/ : 匹配单词 Chapter 的开头三个字符; /ter\b/ : 单词 Chapter 中的字符串 ter，因为它出现在字边界的前面; /\Bapt/ : 匹配 Chapter 中的字符串 apt，但不匹配 aptitude 中的字符串 apt。 因为字符串 apt 出现在单词 Chapter 中的非字边界处，但出现在单词 aptitude 中的字边界处。 项目中的实例（1）有这样一个字符串：’op_content-&gt;”$.roomid”‘ 或 ‘op_content-&gt;”$.rid”‘。现在需要将roomid或者rid抽取出来。 在php中的实现： 1&apos;/^(op_content-&gt;\&quot;\$\.)+(\w+)/&apos; （2）对于字符串： ① ‘/panda/fa6d953b44b505dee6522d2be6e29b66.flv?domain=flv-live-qn.panda.tv’ ② ‘/panda/fa6d953b44b505dee6522d2be6e29b66.flv’。 需要从中抽取出：① panda；② fa6d953b44b505dee6522d2be6e29b66； ③ flv 在php中的实现： 1&apos;#/(.+)/(\w+)\.(\w+)#&apos; 在php中的正则，匹配模式的开头与结尾需要成对，即上边所看到的#。由于需要匹配字符串中的/，所以不能再以/开头和结尾。同样的，如果需要匹配字符串中的特殊符号，该特殊符号也不可以作为开头和结尾的标识。]]></content>
      <categories>
        <category>regular</category>
      </categories>
      <tags>
        <tag>regular</tag>
        <tag>expression</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Time Zone]]></title>
    <url>%2F2017%2F06%2F08%2Ftimezone%2F</url>
    <content type="text"><![CDATA[最近在分析CDN拉流日志的时候，看到了这样的时间格式：2017-06-06T00:58:13+08:00一直对于各种时间缩写不太清楚，于是整理一篇关于这方面的内容。 上边的日期格式什么含义？先说结论：2017-06-06T00:58:13+08:00，它代表东八区2017年6月6日00点58分13秒。为什么日期格式中间还有一个T呢？这是国际标准化组织的日期和时间表示方法规定的。 wikipedia链接：国际标准ISO 8601 在ISO 8601中规定，在合并表示日期和时间的时候，要在时间前边加大写字母T +08:00代表，该时间所属的时区是东八区 各种时间概念UTC整个地球被分为24个时区，每个时区都有自己的本地时间，正如上边的北京时间一样。为了统一起见，出现了协调世界时，又称世界标准时间或世界协调时间，简称UTC(Universal Time Coordinated)，是最主要的世界时间标准，其以原子时秒长为基础，在时刻上接近于格林尼治标准时间。 本地时间与UTC转换：UTC + 时区 = 本地时间。时区东为正，西为负。如东八区表示为+08:00。 GMTGMT(Greenwich Mean Time)格林尼治标准时间（有些翻译为格林尼治平均时间）。但是由于地球在它的椭圆轨道里运行速度不均匀，这个时刻可能与实际的太阳时有误差。格林尼治时间基于天文观测本身的缺陷，已经不再被作为标准时间使用。现在的标准时间，是由原子钟报时的协调世界时（UTC）来决定的。 DST夏日节约时间，简称DST(Daylight Saving Time)。夏季太阳升起较早，人为地将时间提前一小时，以充分利用光照资源，节约照明用电。这个构想于1784年由美国班杰明•富兰克林提出来，1915年德国成为第一个正式实施夏令日光节约时间的国家，以削减灯光照明和耗电开支。 自此以后，全球以欧洲和北美为主的约70个国家都引用这个做法。它与UTC和GMT完全没有关系，完全是人为行为。 CSTCST可以指下列的时区： 大中华地区时区：China Standard Time 澳洲中部时间：Central Standard Time (Australia) 中部标准时区（北美洲），Central Standard Time (North America) 古巴标准时间，Cuba Standard Time 因此，CST是转换后的本地时间。如果忽略UTC和GMT的差异，可以认为中国北京的标准时间为： GMT + 8 = UTC + 8 = CST EST/PST等美国横跨西五区至西十区，共六个时区。每个时区对应一个标准时间，从东向西分别为： 东部时间(EST)(西五区时间) 中部时间(CST)(西六区时间) 山地时间(MST)(西七区时间) 太平洋时间(西部时间)(PST)(西八区时间) 阿拉斯加时间(AKST)(西九区时间) 夏威夷时间(HST) (西十区时间)按照“东早西晚”的规律，各递减一小时。 以上所提到的各种时间里，UTC和GMT是和时区无关的，而CST/DST等是与时区紧密相关的。 计算机时间计算机保存的时间是自UTC时间1970年1月1日00:00:00经过的秒数。最早出现的UNIX操作系统考虑到计算机产生的年代和应用的时限综合取了1970年1月1日作为UNIX TIME的纪元时间(开始时间)。时间戳是指格林威治时间1970年01月01日00时00分00秒(北京时间1970年01月01日08时00分00秒)起至现在的总秒数。]]></content>
      <categories>
        <category>timezone</category>
      </categories>
      <tags>
        <tag>timezone</tag>
        <tag>UTC</tag>
        <tag>GMT</tag>
        <tag>DST</tag>
        <tag>CST</tag>
        <tag>EST</tag>
        <tag>PST</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[xdebug -- debug tool for php]]></title>
    <url>%2F2017%2F06%2F01%2Fxdebug%2F</url>
    <content type="text"><![CDATA[如果你现在的调试还是在使用var_dump()或者print_r()，那么xdebug可能会让你的调试更加得心应手，就像平常断点单步调试一样，你可以直观的看见所有的过程与值。与任何东西的学习方式一样，官方文档 永远是最好的老师： xdebug官方文档 :) 什么？你不想看英文文档？ 还好你找到了这里~下边是linux下xdebug的安装及配置方法： Step 1 下载并解压xdebug扩展包12wget https://xdebug.org/files/xdebug-2.5.4.tgztar -zxvf xdebug-2.5.4.tgz Tips： 具体下载哪个版本的包，可以到xdebug的download页面查找：download windows用户下载.dll后缀的文件，linux用户下载source包 Step 2 编译xdebug12345cd debug-2.5.4phpize（编译你要添加的扩展模块的命令）./configuremakecp modules/xdebug.so /usr/local/php-7.0.9/lib/php/extensions/no-debug-non-zts-20151012 Step 3 配置php.ini对于PHP5.3之前的版本： add: zend_extension_ts=”/wherever/you/put/it/xdebug.so” 对于PHP5.3之后的版本（我的php版本是7.0.9）： From PHP 5.3 onwards, you always need to use the zend_extension PHP.ini setting name, and not zend_extension_ts, nor zend_extension_debug. 在我的php.ini中，关于xdebug的配置如下： 其中remote_host与remote_port按照自己的需求指定。保存php.ini后重启apache或nginx。 Step 4 配置phpstorm的xdebug1. 指定xdebug port这里的port需要与php.ini配置的remote_port一致。 2. 配置DBGp ProxyIDE Key：与php.ini中xdebug.idekey相同Host：项目所在位置Port：项目监听端口 Step 5 安装chrome扩展 Xdebug helper在IDE Key中选择PhpStorm，并设置Key为PHPSTORM（与之前的xdebug.idekey相同即可） 到此为止，所有的准备工作就已经完成了，下面来测试一下~！ Step 6 测试 在phpstorm中设置代码断点，然后开启debug监听 打开浏览器中Xdebug helper的debug模式 访问存在断点的代码位置如果没问题的话，在phpstorm中应该可以看到： 进入debug控制台点击accept就可以看到debug控制台了 that’s done~!]]></content>
      <categories>
        <category>php</category>
      </categories>
      <tags>
        <tag>xdebug</tag>
        <tag>php</tag>
        <tag>phpstorm</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[First Step]]></title>
    <url>%2F2017%2F05%2F31%2Ffirst-blog%2F</url>
    <content type="text"><![CDATA[这是我的第一篇博文，采用了hexo + Github Pages构建博客网站，其中还用到了node.js和 git。 构建博客网站的工作并不复杂，过程就不再赘述了，给出一些建站的参考网站： Reference URL： GitPages + Hexo从0到1搭建个人博客 Hexo在github上构建免费的Web应用 NexT主题 从这篇文章开始，来看看会发生什么。]]></content>
      <tags>
        <tag>first</tag>
        <tag>hexo</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Hello World]]></title>
    <url>%2F2017%2F05%2F31%2Fhello-world%2F</url>
    <content type="text"><![CDATA[Welcome to Hexo! This is your very first post. Check documentation for more info. If you get any problems when using Hexo, you can find the answer in troubleshooting or you can ask me on GitHub. Quick StartCreate a new post1$ hexo new "My New Post" More info: Writing Run server1$ hexo server More info: Server Generate static files1$ hexo generate More info: Generating Deploy to remote sites1$ hexo deploy More info: Deployment]]></content>
  </entry>
</search>
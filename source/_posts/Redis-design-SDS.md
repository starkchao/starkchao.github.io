---
title: 《Redis设计与实现》笔记：数据结构与对象 - 简单动态字符串
date: 2017-11-15 17:17:39
tags:
- redis
categories: "redis"
---
Redis没有直接使用C语言传统的字符串表示（以空字符（'\0'）结尾的字符数组），而是自己构建了一种名为**简单动态字符串**（**simply dynamic string，SDS**）的抽象类型，并将SDS用作Redis的默认字符串表示。
<!--more-->
### <font color=#0099ff size=5>简介</font>
在Redis里，C字符串只会作为字符串字面量，用在一些无需对字符串值进行修改的地方，比如打印日志：
> redisLog(REDIS_WARNING,"Redis is now ready to exit, bye bye...");

当Redis需要一个可以被修改的字符串值时，Redis就会使用SDS来表示字符串值，比如包含字符串值的键值对在底层就是由SDS实现的。

例如客户端执行命令：
> redis> SET msg "hello world"
> OK

那么Redis将在数据库中创建了一个新的键值对，其中：
- 键值对的键是一个字符串对象，对象的底层实现是一个保存着字符串“msg”的SDS
- 键值对的值也是一个字符串对象，对象的底层实现是一个保存着字符串“hello world”的SDS

### <font color=#0099ff size=5>SDS的定义</font>
SDS图示例：<div align=center>![sds-example](/img/2017/11/15/sds-example.png)图1</div>
- free属性值为0，代表SDS没有未使用空间
- len属性值为5，代表SDS保存了5字节长的字符串
- buf属性是一个char类型的数组，数组前五个字节分别保存了'R','e','d','i','s'，最后一个字节保存了空字符'\0'
可以看到，**SDS遵循了C字符串以空字符结尾的惯例**，这样做的好处是SDS可以直接重用C字符串里的一些函数。
此外，保存空字符的1字节空间不计算在SDS的len属性里面。为空字符分配1字节空间以及添加空字符到字符串末尾等操作都是由SDS函数自动完成。

### <font color=#0099ff size=5>SDS与C字符串的区别</font>
SDS比传统的C字符串更能满足Redis对字符串在安全性、效率、已经功能方面的要求。
##### 1.常数复杂度获取字符串长度
由于C字符串并不记录自身的长度信息，所以为了获取一个字符串的长度，必须遍历整个字符串，对遇到的每个字符进行计数，直到遇到代表字符串结尾的空字符为止，这个操作的复杂度为O(N)。
而SDS在len属性中记录了SDS本身的长度，所以获取一个SDS长度的复杂度为O(1)，并且设置和更新SDS长度的工作是由SDS的API在执行时自动完成的。
通过使用SDS，Redis将获取字符串长度所需的复杂度从O(N)降低到了O(1)，这确保了获取字符串长度的工作不会成为Redis的性能瓶颈。
##### 2.杜绝缓冲区溢出
C字符串不记录自身长度带来的另外一个问题就是**容易造成缓冲区溢出**（buffer overflow）
举个例子，strcat函数将src字符串中的内容拼接到dest字符串的末尾：
> char *strcat(char *dest, const char *src);

由于C字符串不记录自身的长度，所以strcat假定用户在执行这个函数时，已经为dest分配了足够多的内存，可以容纳src字符串中的所有内容，而一旦这个假设不成立时，就会产生**缓冲区溢出**。

举个例子，假如程序里有两个在内存中紧邻着的C字符串s1和s2，其中s1保存了字符串“Redis”，s2保存了字符串“MongoDB”，如下图：<div align=center>![sds-overflow-1](/img/2017/11/15/sds-overflow-1.png)图2</div>
如果执行：
> strcat(s1, " Cluster");

目的是将s1的内容修改为“Redis Cluster”，但在执行之前却没有为s1分配足够的空间，那么在strcat函数执行之后，**s1的数据将溢出到s2所在的空间中**，导致s2保存的内容被意外地修改，<div align=center>![sds-overflow-2](/img/2017/11/15/sds-overflow-2.png)图3</div>

与C字符串不同，**SDS的空间分配策略完全杜绝了发生缓冲区溢出的可能性**。举个例子：SDS的API里面也有一个执行拼接操作的sdscat函数，它可以将一个C字符串拼接到给定SDS所保存的字符串的后面，但是在执行拼接操作之前，sdscat会先检查给定SDS的空间是否足够（**利用free属性**），如果不够的话，sdscat就会先扩展SDS的空间，然后才执行拼接操作。下边的小节对SDS的空间分配策略进行说明。
##### 3.减少修改字符串时带来的内存重分配次数
由于C字符串并不记录自身长度，所以每次增长或缩短一个C字符串，程序都要对保存这个C字符串的数组进行一次内存重分配操作，包括扩展底层数组的空间大小或释放不再使用的那部分空间。
在一般的程序中，如果修改字符串的情况不太常出现，那么每次修改都执行一次内存重分配是可以接受的。但Redis被应用于数据被频繁修改的场合，显然每次都执行内存重分配是无法接受的。

<font color=#FF6A6A>**敲黑板画重点了**</font>:
为了避免C字符串的这种缺陷，在SDS中使用free属性来标识未使用空间，通过未使用空间，SDS实现了**<font color=#FF6A6A>空间预分配</font>**和**<font color=#FF6A6A>惰性空间释放</font>**两种优化策略。
- <font color=#A2CD5A>空间预分配</font>

空间预分配用于优化SDS的字符串增长操作：当SDS的API对一个SDS进行修改，并且需要对SDS进行空间扩展的时候，程序不仅会为SDS分配修改所必须要的空间，还会为SDS分配额外的未使用空间。
其中，额外分配的未使用空间数量由以下公式决定：
- 如果对SDS进行修改之后，SDS的长度（即len属性值）小于1MB，那么程序分配和len属性同样大小的未使用空间，这时SDS len属性的值将和free属性的值相同。
- 如果对SDS进行修改之后，SDS的长度大于等于1MB，那么程序会分配1MB的未使用空间。

举个例子,对于图1所示的SDS值，如果我们执行
> sdscat(s, " Cluster");

那么sdscat将执行一次内存重分配操作，将SDS的长度（len属性）修改为13字节，并将SDS的未使用空间（free属性）同样修改为13字节，如下图：<div align=center>![sds-modify-1](/img/2017/11/15/sds-modify-1.png)图4</div>
如果这时，我们再次执行:
> sdscat(s, " Tutorial");

那么这次sdscat将不需要执行内存重分配：因为未使用空间里面的13字节足以保存9字节的"Tutorial"，执行之后如下图：<div align=center>![sds-modify-2](/img/2017/11/15/sds-modify-2.png)图5</div>
通过这种预分配策略，SDS将连续增长N次字符串所需的内存重分配次数，**从必定的N次降低为最多N次**。

- <font color=#A2CD5A>惰性空间释放</font>

惰性空间释放用于优化SDS的字符串缩短操作：当SDS的API需要缩短SDS保存的字符串时，程序并不立即使用内存重分配来回收缩短后多出来的字节，而是使用free属性将这些字节的数量记录，并等待将来使用。
> 举个例子，sdstrim函数接受一个SDS和一个C字符串作为参数，从SDS左右两端分别移除所有在C字符串中出现过的字符，比如执行：
> sdstrim(s, "XY");   // 移除 SDS 字符串中的所有 'X' 和 'Y'

会将SDS修改为如下图的样子：<div align=center>![sds-trim](/img/2017/11/15/sds-trim.png)图6</div>
注意执行sdstrim之后的SDS并没有释放多出来的8字节空间，而是**将这8字节空间作为未使用空间保留在了SDS里面**，如果将来要对SDS进行增长操作的话，这些未使用空间就可能派上用场了。
> 举个例子，如果现在执行：
> sdscat(s, " Redis");

那么完成这次sdscat操作将不需要执行内存重分配：因为SDS里面预留的8字节空间已经足以拼接6字节长的"Redis"。
<font color=#FF6A6A>**重点来了**</font>：**通过惰性空间释放策略，SDS避免了缩短字符串时所需的内存重分配操作，并为将来可能有的增长操作提供了优化**。
与此同时，SDS也提供了相应的API，在有需要时，真正地释放SDS里面的未使用空间，因而不必担心惰性空间释放策略会造成内存浪费。
##### 4.二进制安全
C字符串除了字符串的末尾之外，字符串里面不能包含空字符，否则最先被程序读入的空字符将被误认为是字符串结尾——这些限制使得C字符串只能保存文本数据，而不能保存像图片、音频、视频这样的二进制数据。而SDS的API都是二进制安全的：所有SDS API都会以处理二进制的方式来处理SDS存放在buf数组的数据。
通过使用二进制安全的SDS，使得Redis不仅可以保存文本数据，还可以保存任意格式的二进制数据。
##### 5.兼容部分C字符串函数
虽然SDS的API都是二进制安全的，但它们一样遵循C字符串以空字符结尾的惯例，因此SDS可以在有需要时重用<string.h>函数库，从而避免了不必要的代码重复。

### <font color=#0099ff size=5>总结一下</font>
<font color=#FF6A6A>**最后的重点**</font>:C字符串和SDS之间的区别：
<div align=left>![sds-diff](/img/2017/11/15/sds-diff.png)</div>







